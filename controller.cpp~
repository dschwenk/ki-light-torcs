/*	controller class template for AI Light Torcs project
	author: Stefan Moebius
	date: 11.04.2012
*/
#include "controller.h"


#include <fstream>
#include <sstream>
#include <iostream>
using namespace std;



Controller::Controller()
{
	//TODO: evtl. KI Initialisieren

	//TODO: Trainingsdaten von Datei laden

	// LogDatei / Trainingsdatei oeffnen und zeilenweise auslesen
	cout << "\n\nOeffne Trainingsdaten-Datei und importiere Vektoren";
	ifstream trainingDataFile("trainingData.log",ios::in);
	if(trainingDataFile.is_open()){

		// es wird zeilenweise aus Datei gelesen und jeweils in line gespeichert
		string line;
		
		while(getline(trainingDataFile,line)){

			// string parsen und Werte in Vektor ablegen
			stringstream ss(line);
			LineVector* TmpLineVector;
			TmpLineVector = new LineVector();			
			float wert = 0;
			
			for(int i=0;i<ElementeJeVektor;i++){
				ss >> wert;
				TmpLineVector->lv.push_back(wert);
				if(ss.peek() == ','){
					ss.ignore();
				}
			}
			// Vektor ans Ende der Liste anhaengen
			this->LogFileLineVektorList.push_back(TmpLineVector);
		}
			cout << "\nTrainingsdaten importiert\n\n";
	}
	else {
		cout << "\nKonnte Traininsdaten-Datein nicht oeffnen!";
	}
}

Controller::~Controller()
{
	//TODO: Trainingsdaten in Datei abspeichern

	/*
	// Sensorwerte + Fahrzeugaktion in Datei speichern
	// Winkel, Gang, Drehzahl, Tracksensoren (je 3 Werte zu einem Wert zusammengefasst), Gas, Bremse, Gang, Lenkung
	*/

	/*
	cout << "\Schreibe Trainingsdaten\n";
	for(int i=0;i<this->LogFileLineVektorList.size();i++){
		for(int j=0;j<ElementeJeVektor;j++){
			this->SensorDataStream << this->LogFileLineVektorList[i]->lv[j] << ",";
		}
		this->SensorDataStream << "\n";
	}

	this->SensorDataString = this->SensorDataStream.str();

	ofstream trainingDataLog("trainingDataDestOut.log", ios::out | ios::app);
	trainingDataLog << this->SensorDataString;
	trainingDataLog.close();

	*/

	
	// Logging
	//
	// convert stream to string, open stream to log, write data
	this->SensorDataString = this->SensorDataStream.str();

	ofstream trainingDataLog("myLog.log", ios::out | ios::app);
	trainingDataLog << this->SensorDataString;
	trainingDataLog.close();
	
}

float Controller::accelControl(CarState* cs, CarControl* cc)
{
	//TODO: hier code einfügen, der die Beschleunigung des Autos regelt
	//float accel = 1.0f; //Für einen ersten test hier einfach auf "Vollgas" gesetzt...
	//return accel;

	// float accel = 0.0f;	

	// Aufruf der Funktionen in der Reihenfolge
	// generateVector,accelcontrol,brakeControl,steerControl,clutchControl,gearControl
	// Stringoutput : angle, gear, rpm, trackmittelwerte(9 = Mitte),accel,brake,steer,gear

	// K-Nearest-Neighbour zur Berechnung der naechsten Nachbarn
	// Funktionsaufruf aehnlich calcKNearestNeighbour(Uebergabe der benoetigten Sensorwerte, z.B. TrackPosition), Rueckgabe enthaelt Datenstruktur mit Gas,Bremse, Gang, Lenkung

	// calcNearestNeighbour(cs, cc);
	calcKNearestNeighbour(cs, cc);

	float accel = this->KNearest_accel;
	// float accel = 0.5f;

	// Logging
	this->SensorDataStream << accel;
	cout << "accel: " << accel;
	return accel;

}

float Controller::brakeControl(CarState* cs, CarControl* cc)
{
	//TODO: hier code einfügen, der das Auto abbremst, z.B. in Kurven...
	// float brake = 0.0f;

	// Wert wurde von calcKNearestNeighbour berechnet/zurueckgegeben und in XY gespeichert
	float brake = this->KNearest_brake;

	// Logging
	this->SensorDataStream << "," << brake;
	cout << "brake: " << brake;
	return brake;
}

float Controller::steerControl(CarState* cs, CarControl* cc)
{
	//TODO: hier code für die Lenkung einfügen
	//Es muss eine Fleißkommazahl im Wertebereich von -1.0 bis 1.0 zurückgegeben werden.
	//-1.0: stark nach rechts lenken
	// 0.0: in keine Richtung lenken
	// 1.0: stark nach links lenken
	// float steer = 0.2f;

	// Wert wurde von calcKNearestNeighbour berechnet/zurueckgegeben und in XY gespeichert
	float steer = this->KNearest_steer;

	// Logging
	this->SensorDataStream << "," << steer;
	cout << "steer: " << steer;
	return steer;

}


float Controller::clutchControl(CarState* cs, CarControl* cc)
{
	//TODO: Kupplung implementieren (nicht unbedingt nötig)
	float clutch = 0.0f;
	return clutch;
}

int Controller::gearControl(CarState* cs, CarControl* cc)
{
	//TODO: Gangschaltung implementieren
	// mögliche Werte sind -1 (Rückwärtsgang), 0 (Leerlauf), 1, 2, 3, 4, 5, 6
	// int gear = 1; //hier in diesem Beispiel einfach immer 1 Gang verwenden

	// Wert wurde von calcKNearestNeighbour berechnet/zurueckgegeben und in XY gespeichert
	int gear = this->KNearest_gear;

	// Logging
	this->SensorDataStream << "," << gear << "\n";
	cout << "gear: " << gear << "\n" ;
	return gear;
}

void Controller::generateVector(CarState* cs, CarControl* cc)
{
	//TODO: KI Trainieren
	//TODO: Ausgabe durch KI berechnen
	cc->setAccel(accelControl(cs, cc));
	cc->setBrake(brakeControl(cs, cc));
	cc->setSteer(steerControl(cs, cc));
	cc->setClutch(clutchControl(cs, cc));
	cc->setGear(gearControl(cs, cc));
}

void Controller::calcKNearestNeighbour(CarState* cs, CarControl* cc){

	// Berechnung der K naechsten Nachbarn

	// Linevektor index
	// 0		angle
	// 1		distFromStart
	// 2		gear
	// 3		lastLapTime
	// 4-39		opponents
	// 40		rpm
	// 41		speedX
	// 42		speedY
	// 43		speedZ
	// 44-62	track
	// 63		trackPos
	// 64		gear
	// 65		accel
	// 66		brake
	// 67		steering

	// Liste, die die K naechsten Vektoren enthaelt
	list<NearestVector*> NearestVectorList;

	// ersten Vektor mit Nullwerten initialisieren
	NearestVector* TmpNearestVector;
	TmpNearestVector = new NearestVector();
	for(int i=0;i<5;i++){
		(*TmpNearestVector).nv.push_back(0.0);
	}

	// Iterator
	list<NearestVector*>::iterator it;

	float lowestsum = 10000000000000000000.0;
	float sum = 0.0;
	int m;

	cout << "\ncalcKNearestNeighbour";

	// gehe alle Vektoren durch ...
	for(int i=0;i<this->LogFileLineVektorList.size();i++){
		// Tracksensor ID
		m = 0;
		sum = 0.0;
		// berechne Abstand
		for(int j=44;j<=62;j++){
			sum += ((this->LogFileLineVektorList[i]->lv[j] - cs->getTrack(m)) * (this->LogFileLineVektorList[i]->lv[j] - cs->getTrack(m)));
			m++;
		}

		// gehe Liste durch und pruefe ob die Summe kleiner ist als bei einem der K naechsten Vektoren
		for(it=NearestVectorList.begin();it != NearestVectorList.end(); ++it){
			cout << "\npruefe summe kleiner als bei einem k naechsten vektor";			
			if(sum < (*it)->nv[0]){
				// Fuege sum, accel, brake, steer, gear Werte zum Vektor hinzu
				NearestVector* TmpNearestVector;
				TmpNearestVector = new NearestVector();
				(*TmpNearestVector).nv.push_back(sum);
				(*TmpNearestVector).nv.push_back(this->LogFileLineVektorList[i]->lv[65]);
				(*TmpNearestVector).nv.push_back(this->LogFileLineVektorList[i]->lv[66]);
				(*TmpNearestVector).nv.push_back(this->LogFileLineVektorList[i]->lv[67]);
				(*TmpNearestVector).nv.push_back(this->LogFileLineVektorList[i]->lv[64]);
				NearestVectorList.insert(it,TmpNearestVector);

				cout << "\nneuer kleinster vektor";

				// pruefe ob mehr als K Vektoren in der Liste sind
				if(NearestVectorList.size() > K){
					// entferne letztes Element / letzten Vektor aus der Liste
					NearestVectorList.pop_back();
					cout << "\nmehr als k vektoren, letzen vektor loeschen";
				}
			}
		}
	}
	// alle Vektorenabstaende wurden berechnet

	float accelsum = 0, brakesum = 0, steersum = 0;
	int gearsum = 0;
	
	cout << "\nalle Vektorenabstaende wurden berechnet";

	for(it=NearestVectorList.begin();it != NearestVectorList.end(); ++it){
		accelsum += (*it)->nv[1];
		brakesum += (*it)->nv[2];
		steersum += (*it)->nv[3];
		gearsum += (*it)->nv[4];
		cout << "\nberechne accelsum, breakesum etc";
	}

	float accel = accelsum / K;
	float brake = brakesum / K;
	float steer = steersum / K;
	int gear = (int)gearsum / K;

	this->KNearest_accel = accel;
	this->KNearest_brake = brake;
	this->KNearest_steer = steer;
	this->KNearest_gear = gear;

}


void Controller::calcNearestNeighbour(CarState* cs, CarControl* cc){

	// Berechnung des naechsten Nachbarn

	// Linevektor index
	// 0		angle
	// 1		distFromStart
	// 2		gear
	// 3		lastLapTime
	// 4-39		opponents
	// 40		rpm
	// 41		speedX
	// 42		speedY
	// 43		speedZ
	// 44-62	track
	// 63		trackPos
	// 64		gear
	// 65		accel
	// 66		brake
	// 67		steering
	
	float lowestsum = 10000000000000000000.0;
	float sum = 0.0;
	int m;

	// cout << "calcNearestNeighbour";
	
	// gehe alle Vektoren durch ...
	for(int i=0;i<this->LogFileLineVektorList.size();i++){
		// Tracksensor ID
		m = 0;	
		sum = 0.0;
		// berechne Abstand
		for(int j=44;j<=62;j++){
			sum += ((this->LogFileLineVektorList[i]->lv[j] - cs->getTrack(m)) * (this->LogFileLineVektorList[i]->lv[j] - cs->getTrack(m)));
			m++;
		}

		// Naechster Vektor berechnet - Werte im Objekt speichern
		if(sum < lowestsum){
			this->currentLowest_accel = this->LogFileLineVektorList[i]->lv[65];
			this->currentLowest_brake = this->LogFileLineVektorList[i]->lv[66];
			this->currentLowest_gear = this->LogFileLineVektorList[i]->lv[64];
			this->currentLowest_steer = this->LogFileLineVektorList[i]->lv[67];
	
			lowestsum = sum;
		}
	}
	
}
